#!/usr/bin/python3
#
# Aggregate bans into subnet rules for fail2ban
#
# Copyright 2025 Alexandre Rossi <niol@zincube.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, see <https://www.gnu.org/licenses/>.


import argparse
import ipaddress
import itertools
import logging
import os
import sys


import fail2ban.client.csocket


# FIXME: remove when python 3.12 is more common
def batched(iterable, chunk_size):
    iterator = iter(iterable)
    while chunk := tuple(itertools.islice(iterator, chunk_size)):
        yield chunk


def bad_networks(bad_treshold, ip_population):
    subnets = {}

    # populate counts for each subnet
    for ip_str in ip_population:
        try:
            ip = ipaddress.ip_address(ip_str)
        except ValueError:
            # already a banned subnet, ignore
            continue

        if ip.version == 4:
            netmask = 24
            Network = ipaddress.IPv4Network
        elif ip.version == 6:
            netmask = 48
            Network = ipaddress.IPv6Network
        else:
            raise ValueError

        net = Network(
            (
                ip,
                netmask,
            ),
            strict=False,
        )
        if net in subnets:
            subnets[net].append(ip)
        else:
            subnets[net] = [ip]

    logging.debug("  Those ips belong to %d sub-networks.", len(subnets.keys()))

    # cleanup subnets below population treshold
    for subnet in subnets.copy():
        if len(subnets[subnet]) < bad_treshold:
            # we have less ips than treshold
            del subnets[subnet]

    logging.debug(
        "  In those sub-networks, %d have more than %d banned ips",
        len(subnets.keys()),
        bad_treshold,
    )

    return subnets


class Fail2banClient:
    """
    Simple client for interacting with the Fail2ban client. Based on the
    original source.
    """

    def __init__(self, socket: str) -> None:
        self.client = fail2ban.client.csocket.CSocket(socket)

    def _send_command(self, cmd: list[str]) -> list:
        """
        Send a command to the Fail2ban server, and wait for a response.
        """

        ret = self.client.send(cmd)

        if ret[0] != 0:
            return

        return ret[1]

    def close(self):
        self.client.close()

    def get_jail_status(self, jail: str) -> dict:
        """
        Return the status of a specific jail.
        """

        response = self._send_command(["status", jail])

        if not response:
            return []

        # Restructure the response.
        response = {k: v for k, v in response}

        if "Actions" in response:
            response["Actions"] = {k: v for k, v in response["Actions"]}

        if "Filter" in response:
            response["Filter"] = {k: v for k, v in response["Filter"]}

        return response

    def get_status(self) -> list[dict]:
        """
        Return the status information.
        """

        response = self._send_command(["status"])

        if not response:
            return []

        # Restructure the response.
        response = {k: v for k, v in response}

        if "Jail list" in response:
            response["Jail list"] = [
                j.strip() for j in response["Jail list"].split(",")
            ]

        return response

    def get_jails(self) -> list:
        return self.get_status()["Jail list"]

    def get_banned(self, jail: str) -> list:
        return self.get_jail_status(jail)["Actions"]["Banned IP list"]

    def _ips_cmd(self, cmd, cmd_log, jail, ips):
        if type(ips) is not list:
            logging.debug("jail [%s] %s %s...", jail, cmd_log, ips)
            ips = [ips]
        else:
            logging.debug("jail [%s] %s %d ips...", jail, cmd_log, len(ips))

        for ip_batch in batched(ips, 10):
            self._send_command(["set", jail, cmd] + ips)

    def ban(self, jail, ips):
        self._ips_cmd("banip", "Banning", jail, ips)

    def unban(self, jail, ips):
        self._ips_cmd("unbanip", "Unbanning", jail, ips)


def ban_subnets(args):
    try:
        f2b = Fail2banClient("/var/run/fail2ban/fail2ban.sock")
    except FileNotFoundError:
        logging.error("Could not find fail2ban server socket.")
        sys.exit(1)

    for jail in f2b.get_jails():
        banned = f2b.get_banned(jail)
        logging.debug("jail [%s] Found %d banned ips", jail, len(banned))
        for badnet, ips in bad_networks(args.count_limit, banned).items():
            logging.info(
                "jail [%s] Identified %s with %d bad ips", jail, badnet, len(ips)
            )
            if not args.dryrun:
                f2b.unban(jail, ips)
                f2b.ban(jail, badnet)

    f2b.close()


def print_subnets(args):
    banned = None
    with open(args.input_file) as f:
        banned = [l.strip() for l in f]

    for badnet, ips in bad_networks(args.count_limit, banned).items():
        logging.debug(f"Network {badnet}:")
        for ip in ips:
            logging.debug(f"\t{ip}")


if __name__ == "__main__":
    count_limit_default = 7

    parser = argparse.ArgumentParser(
        description="Scan fail2ban bans and aggregate single banned IP addresses into banned networks",
        epilog="Defaults: COUNTLIMIT={}".format(str(count_limit_default)),
    )

    parser.add_argument("-v", "--verbose", action="store_true")
    parser.add_argument("-q", "--quiet", action="store_true")
    parser.add_argument("-D", "--dryrun", action="store_true")
    parser.add_argument(
        "-l", "--count-limit", action="store", type=int, default=count_limit_default
    )
    parser.add_argument(
        "-f",
        "--input-file",
        action="store",
        help="Take this plain text file as list of input IPs instead of asking f2b (for testing purposes). Implies --dryrun",
    )

    args = parser.parse_args()

    log = logging.getLogger()

    if os.getenv("INVOCATION_ID"):  # running as systemd unit
        import systemd.journal

        log_handler = systemd.journal.JournalHandler(
            SYSLOG_IDENTIFIER="fail2ban-subnet"
        )
    else:
        log_handler = logging.StreamHandler(sys.stdout)
        log_handler.setFormatter(logging.Formatter("%(levelname)s:%(message)s"))

    if args.verbose:
        log_level = logging.DEBUG
    elif args.quiet:
        log_level = logging.ERROR
    else:
        log_level = logging.INFO

    log.setLevel(log_level)
    log.addHandler(log_handler)

    if args.input_file:
        args.dryrun = True
        print_subnets(args)
    else:
        ban_subnets(args)

    logging.shutdown()
