#!/usr/bin/python3
#
# Aggregate bans into subnet rules for fail2ban
#
# Copyright 2025 Alexandre Rossi <niol@zincube.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, see <https://www.gnu.org/licenses/>.


import argparse
import ipaddress
import itertools
import logging
import sys


import fail2ban.client.csocket
import systemd.journal


# FIXME: remove when python 3.12 is more common
def batched(iterable, chunk_size):
    iterator = iter(iterable)
    while chunk := tuple(itertools.islice(iterator, chunk_size)):
        yield chunk


def bad_networks(bad_treshold, ip_population):
    subnets = {}

    # populate counts for each subnet
    for ip_str in ip_population:
        try:
            ip = ipaddress.ip_address(ip_str)
        except ValueError:
            # already a banned subnet, ignore
            continue

        if ip.version == 4:
            netmask = 24
            Network = ipaddress.IPv4Network
        elif ip.version == 6:
            netmask = 48
            Network = ipaddress.IPv6Network
        else:
            raise ValueError

        net = Network(
            (
                ip,
                netmask,
            ),
            strict=False,
        )
        if net in subnets:
            subnets[net].append(ip)
        else:
            subnets[net] = [ip]

    logging.debug("Those ips belong to %d sub-networks.", len(subnets.keys()))

    # cleanup subnets below population treshold
    for subnet in subnets.copy():
        try:
            subnets[subnet][bad_treshold + 1]
        except IndexError:
            # we have less ips than treshold
            del subnets[subnet]

    logging.debug(
        "In those sub-networks, %d have more than %d banned ips",
        len(subnets.keys()),
        bad_treshold,
    )

    return subnets


class Fail2banClient:
    """
    Simple client for interacting with the Fail2ban client. Based on the
    original source.
    """

    def __init__(self, socket: str) -> None:
        self.client = fail2ban.client.csocket.CSocket(socket)

    def _send_command(self, cmd: list[str]) -> list:
        """
        Send a command to the Fail2ban server, and wait for a response.
        """

        ret = self.client.send(cmd)

        if ret[0] != 0:
            return

        return ret[1]

    def close(self):
        self.client.close()

    def get_jail_status(self, jail: str) -> dict:
        """
        Return the status of a specific jail.
        """

        response = self._send_command(["status", jail])

        if not response:
            return []

        # Restructure the response.
        response = {k: v for k, v in response}

        if "Actions" in response:
            response["Actions"] = {k: v for k, v in response["Actions"]}

        if "Filter" in response:
            response["Filter"] = {k: v for k, v in response["Filter"]}

        return response

    def get_status(self) -> list[dict]:
        """
        Return the status information.
        """

        response = self._send_command(["status"])

        if not response:
            return []

        # Restructure the response.
        response = {k: v for k, v in response}

        if "Jail list" in response:
            response["Jail list"] = [
                j.strip() for j in response["Jail list"].split(",")
            ]

        return response

    def get_jails(self) -> list:
        return self.get_status()["Jail list"]

    def get_banned(self, jail: str) -> list:
        return self.get_jail_status(jail)["Actions"]["Banned IP list"]

    def _ips_cmd(self, cmd, cmd_log, jail, ips):
        if type(ips) is not list:
            logging.debug("%s %s for jail %s...", cmd_log, ips, jail)
            ips = [ips]
        else:
            logging.debug("%s %d ips for jail %s...", cmd_log, len(ips), jail)

        for ip_batch in batched(ips, 10):
            self._send_command(["set", jail, cmd] + ips)

    def ban(self, jail, ips):
        self._ips_cmd("banip", "Banning", jail, ips)

    def unban(self, jail, ips):
        self._ips_cmd("unbanip", "Unbanning", jail, ips)


if __name__ == "__main__":
    count_limit_default = 7

    parser = argparse.ArgumentParser(
        description="Scan fail2ban bans and aggregate single banned IP addresses into banned networks",
        epilog="Defaults: COUNTLIMIT={}".format(str(count_limit_default)),
    )

    parser.add_argument("-v", "--verbose", action="store_true")
    parser.add_argument("-q", "--quiet", action="store_true")
    parser.add_argument("-D", "--dryrun", action="store_true")
    parser.add_argument(
        "-l", "--count-limit", action="store", type=int, default=count_limit_default
    )

    args = parser.parse_args()

    count_limit = args.count_limit

    log = logging.getLogger()

    if args.verbose:
        log_level = logging.DEBUG
        log_handler = logging.StreamHandler(sys.stdout)
        log_handler.setFormatter(logging.Formatter("%(levelname)s:%(message)s"))
    else:
        log_level = logging.INFO
        log_handler = systemd.journal.JournalHandler(
            SYSLOG_IDENTIFIER="fail2ban-subnet"
        )

    log.setLevel(log_level)
    log.addHandler(log_handler)

    try:
        f2b = Fail2banClient("/var/run/fail2ban/fail2ban.sock")
    except FileNotFoundError:
        logging.error("Could not find fail2ban server socket.")
        sys.exit(1)

    for jail in f2b.get_jails():
        banned = f2b.get_banned(jail)
        logging.debug("Found %d banned ips for jail %s", len(banned), jail)
        for badnet, ips in bad_networks(count_limit, banned).items():
            logging.info("Identified %s with %d bad ips", badnet, len(ips))
            if not args.dryrun:
                f2b.unban(jail, ips)
                f2b.ban(jail, badnet)

    f2b.close()
    logging.shutdown()
