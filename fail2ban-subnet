#!/usr/bin/python3
#
# Aggregate bans into subnet rules for fail2ban
#
# Copyright 2025 Alexandre Rossi <niol@zincube.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, see <https://www.gnu.org/licenses/>.


import argparse
import collections
import ipaddress
import itertools
import logging
import os
import sys
import typing


import fail2ban.client.csocket


class V4_NETMASKS(typing.NamedTuple):
    smallest = 24
    biggest = 16
    search_step = 2


class V6_NETMASKS(typing.NamedTuple):
    smallest = 64
    biggest = 48
    search_step = 8


# FIXME: remove when python 3.12 is more common
def batched(iterable, chunk_size):
    iterator = iter(iterable)
    while chunk := tuple(itertools.islice(iterator, chunk_size)):
        yield chunk


def smallest_net_from(ip):
    if ip.version == 4:
        netmask = V4_NETMASKS.smallest
        Network = ipaddress.IPv4Network
    elif ip.version == 6:
        netmask = V6_NETMASKS.smallest
        Network = ipaddress.IPv6Network
    else:
        raise ValueError

    return Network(
        (
            ip,
            netmask,
        ),
        strict=False,
    )


def cluster_networks(subnets, search_netmasks):
    bad_subnets_clusters = subnets.copy()
    could_not_expand_count = {}
    for netmask in search_netmasks:
        bad_subnets = list(bad_subnets_clusters.keys())
        bad_subnets.sort()
        bad_subnets_last_idx = len(bad_subnets) - 1
        for idx in range(0, bad_subnets_last_idx):
            subnet = bad_subnets[idx]
            if subnet in could_not_expand_count and could_not_expand_count[subnet] > 4:
                # could not previously expand to adjacent subnets, stop here to
                # avoid big supernets with few bad ips
                continue
            wider_net = subnet.supernet(new_prefix=netmask)
            before = range(idx - 1, 0, -1)
            after = range(idx + 1, bad_subnets_last_idx)
            could_expand = False
            for search in (before, after):
                for idx_search in search:
                    candidate = bad_subnets[idx_search]
                    if candidate not in bad_subnets_clusters:
                        # candidate already consolidated into another supernet
                        continue
                    if candidate.subnet_of(wider_net):
                        could_expand = True
                        if wider_net in bad_subnets_clusters:
                            bad_subnets_clusters[wider_net].update(
                                bad_subnets_clusters[candidate]
                            )
                        else:
                            bad_subnets_clusters[wider_net] = bad_subnets_clusters[
                                candidate
                            ]
                        del bad_subnets_clusters[candidate]
                    else:
                        break
                if not could_expand:
                    if subnet in could_not_expand_count:
                        could_not_expand_count[subnet] = (
                            could_not_expand_count[subnet] + 1
                        )
                    else:
                        could_not_expand_count[subnet] = 1

    return bad_subnets_clusters


def bad_networks(bad_treshold, ip_population):
    subnets = collections.OrderedDict()

    # populate counts for each smallest subnet
    for ip_str in ip_population:
        try:
            ip = ipaddress.ip_address(ip_str)
        except ValueError:
            # already a banned subnet
            ip = ipaddress.ip_network(ip_str)
            net = ip
        else:
            net = smallest_net_from(ip)

        if net in subnets:
            subnets[net].add(ip)
        else:
            subnets[net] = {ip}

    logging.debug(
        "  Those ips belong to %d smallest sub-networks.", len(subnets.keys())
    )

    # cleanup subnets below population treshold
    for subnet in subnets.copy():
        if len(subnets[subnet]) < bad_treshold:
            # we have less ips than treshold
            del subnets[subnet]

    logging.debug(
        "  In those sub-networks, %d have more than %d banned ips",
        len(subnets.keys()),
        bad_treshold,
    )

    # cluster adjacent above treshold subnets
    v4subnets = {s: subnets[s] for s in subnets if s.version == 4}
    bad_networks = cluster_networks(
        v4subnets,
        range(V4_NETMASKS.smallest, V4_NETMASKS.biggest - 1, -V4_NETMASKS.search_step),
    )
    v6subnets = {s: subnets[s] for s in subnets if s.version == 6}
    bad_networks.update(
        cluster_networks(
            v6subnets,
            range(
                V6_NETMASKS.smallest, V6_NETMASKS.biggest - 1, -V6_NETMASKS.search_step
            ),
        )
    )

    return bad_networks


class Fail2banClient:
    """
    Simple client for interacting with the Fail2ban client. Based on the
    original source.
    """

    def __init__(self, socket: str) -> None:
        self.client = fail2ban.client.csocket.CSocket(socket)

    def _send_command(self, cmd: list[str]) -> list:
        """
        Send a command to the Fail2ban server, and wait for a response.
        """

        ret = self.client.send(cmd)

        if ret[0] != 0:
            return

        return ret[1]

    def close(self):
        self.client.close()

    def get_jail_status(self, jail: str) -> dict:
        """
        Return the status of a specific jail.
        """

        response = self._send_command(["status", jail])

        if not response:
            return []

        # Restructure the response.
        response = {k: v for k, v in response}

        if "Actions" in response:
            response["Actions"] = {k: v for k, v in response["Actions"]}

        if "Filter" in response:
            response["Filter"] = {k: v for k, v in response["Filter"]}

        return response

    def get_status(self) -> list[dict]:
        """
        Return the status information.
        """

        response = self._send_command(["status"])

        if not response:
            return []

        # Restructure the response.
        response = {k: v for k, v in response}

        if "Jail list" in response:
            response["Jail list"] = [
                j.strip() for j in response["Jail list"].split(",")
            ]

        return response

    def get_jails(self) -> list:
        return self.get_status()["Jail list"]

    def get_banned(self, jail: str) -> list:
        return self.get_jail_status(jail)["Actions"]["Banned IP list"]

    def _ips_cmd(self, cmd, cmd_log, jail, ips):
        if type(ips) is not list:
            logging.debug("jail [%s] %s %s...", jail, cmd_log, ips)
            ips = [ips]
        else:
            logging.debug("jail [%s] %s %d ips...", jail, cmd_log, len(ips))

        for ip_batch in batched(ips, 10):
            self._send_command(["set", jail, cmd] + ips)

    def ban(self, jail, ips):
        self._ips_cmd("banip", "Banning", jail, ips)

    def unban(self, jail, ips):
        self._ips_cmd("unbanip", "Unbanning", jail, ips)


def ban_subnets(args):
    try:
        f2b = Fail2banClient("/var/run/fail2ban/fail2ban.sock")
    except FileNotFoundError:
        logging.error("Could not find fail2ban server socket.")
        sys.exit(1)

    for jail in f2b.get_jails():
        banned = f2b.get_banned(jail)
        logging.debug("jail [%s] Found %d banned ips", jail, len(banned))
        for badnet, ips in bad_networks(args.count_limit, banned).items():
            logging.info(
                "jail [%s] Identified %s with %d bad ips", jail, badnet, len(ips)
            )
            if args.dryrun:
                for ip in ips:
                    logging.debug(f"\t{ip}")
            else:
                f2b.unban(jail, ips)
                f2b.ban(jail, badnet)

    f2b.close()


def print_subnets(args):
    banned = None
    with open(args.input_file) as f:
        banned = [l.strip() for l in f]

    for badnet, ips in bad_networks(args.count_limit, banned).items():
        logging.debug(f"Network {badnet}:")
        for ip in ips:
            logging.debug(f"\t{ip}")


if __name__ == "__main__":
    count_limit_default = 7

    parser = argparse.ArgumentParser(
        description="Scan fail2ban bans and aggregate single banned IP addresses into banned networks",
        epilog="Defaults: COUNTLIMIT={}".format(str(count_limit_default)),
    )

    parser.add_argument("-v", "--verbose", action="store_true")
    parser.add_argument("-q", "--quiet", action="store_true")
    parser.add_argument("-D", "--dryrun", action="store_true")
    parser.add_argument(
        "-l", "--count-limit", action="store", type=int, default=count_limit_default
    )
    parser.add_argument(
        "-f",
        "--input-file",
        action="store",
        help="Take this plain text file as list of input IPs instead of asking f2b (for testing purposes). Implies --dryrun",
    )

    args = parser.parse_args()

    log = logging.getLogger()

    if os.getenv("INVOCATION_ID"):  # running as systemd unit
        import systemd.journal

        log_handler = systemd.journal.JournalHandler(
            SYSLOG_IDENTIFIER="fail2ban-subnet"
        )
    else:
        log_handler = logging.StreamHandler(sys.stdout)
        log_handler.setFormatter(logging.Formatter("%(levelname)s:%(message)s"))

    if args.verbose:
        log_level = logging.DEBUG
    elif args.quiet:
        log_level = logging.ERROR
    else:
        log_level = logging.INFO

    log.setLevel(log_level)
    log.addHandler(log_handler)

    if args.input_file:
        args.dryrun = True
        print_subnets(args)
    else:
        ban_subnets(args)

    logging.shutdown()
