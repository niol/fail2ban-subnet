#!/usr/bin/python3
#
# Aggregate bans into subnet rules for fail2ban
#
# Copyright 2025 Alexandre Rossi <niol@zincube.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, see <https://www.gnu.org/licenses/>.


import argparse
import ipaddress
import itertools
import logging
import os
import sys
import typing


class V4_NETMASKS(typing.NamedTuple):
    smallest = 24
    biggest = 16
    search_step = 2


class V6_NETMASKS(typing.NamedTuple):
    smallest = 64
    biggest = 48
    search_step = 8


V4_SEARCH_NETMASKS = range(
    V4_NETMASKS.smallest, V4_NETMASKS.biggest - 1, -V4_NETMASKS.search_step
)
V6_SEARCH_NETMASKS = range(
    V6_NETMASKS.smallest, V6_NETMASKS.biggest - 1, -V6_NETMASKS.search_step
)


# FIXME: replace with itertools.batched() when python 3.12 is more common
def batched(iterable, chunk_size):
    iterator = iter(iterable)
    while chunk := tuple(itertools.islice(iterator, chunk_size)):
        yield chunk


def is_network(ip):
    return hasattr(ip, "prefixlen")


def smallest_net_from(ip):
    if ip.version == 4:
        netmask = V4_NETMASKS.smallest
        Network = ipaddress.IPv4Network
    elif ip.version == 6:
        netmask = V6_NETMASKS.smallest
        Network = ipaddress.IPv6Network
    else:
        raise ValueError

    return Network(
        (
            ip,
            netmask,
        ),
        strict=False,
    )


def subnets_important(bad_treshold, ip_population):
    subnets = {}

    # populate ips for each smallest subnet
    for ip_str in ip_population:
        try:
            ip = ipaddress.ip_address(ip_str)
        except ValueError:
            # already a banned subnet
            ip = ipaddress.ip_network(ip_str)
            net = ip
        else:
            net = smallest_net_from(ip)

        if net in subnets:
            subnets[net].add(ip)
        else:
            subnets[net] = {ip}

    # cleanup subnets below population treshold
    unimportant = set()
    for subnet in subnets.copy():
        # important if
        #    we have more ips than treshold
        # or
        #    already a subnet
        important = len(subnets[subnet]) >= bad_treshold or is_network(
            next(iter(subnets[subnet]))
        )

        if not important:
            unimportant.update(subnets[subnet])
            del subnets[subnet]

    return (
        dict(sorted(subnets.items(), key=lambda kv: (kv[0].version, kv[1]))),
        unimportant,
    )


def subnets_find_clusters(subnets_cluster_counts, prefixlen):
    subnets = list(subnets_cluster_counts.keys())
    clustering_subnets = {}

    for idx in range(0, len(subnets)):
        subnet = subnets[idx]

        if prefixlen < subnet.prefixlen:
            wider_net = subnet.supernet(new_prefix=prefixlen)
        else:
            # already a bigger subnet, keep
            clustering_subnets[subnet] = 0
            continue

        last_count = subnets_cluster_counts[subnet]
        if last_count > 2:
            # we did not find neighbors last times
            if wider_net not in clustering_subnets:
                # keep and stop trying to expand
                clustering_subnets[subnet] = last_count + 1
            else:
                # other subnets overlap this one, drop
                pass
            continue

        no_candidate = True
        for candidate in subnets[idx + 1 :]:
            if candidate.subnet_of(wider_net):
                no_candidate = False
                clustering_subnets[wider_net] = 0
            else:
                break

        if no_candidate:
            # handle the case of the last subnet being in the last cluster
            if wider_net not in clustering_subnets:
                clustering_subnets[subnet] = subnets_cluster_counts[subnet] + 1

    return clustering_subnets


def subnets_cluster(subnets, search_netmasks):
    clusters = {s: 0 for s in subnets}
    for netmask in search_netmasks:
        if clusters:
            clusters = subnets_find_clusters(clusters, netmask)
        else:
            break
    return clusters


def bad_networks(bad_treshold, ip_population):
    subnets, unimportant = subnets_important(bad_treshold, ip_population)

    logging.debug(
        "  %d subnets have more than %d banned ips",
        len(subnets.keys()),
        bad_treshold,
    )

    # cluster adjacent above treshold subnets
    v4subnets = [s for s in subnets if s.version == 4]
    v4bad_networks = subnets_cluster(v4subnets, V4_SEARCH_NETMASKS)
    v6subnets = [s for s in subnets if s.version == 6]
    v6bad_networks = subnets_cluster(v6subnets, V6_SEARCH_NETMASKS)

    # group ip population into identified clustered subnets
    bad_networks = list(v4bad_networks.keys()) + list(v6bad_networks.keys())
    bad_networks_defs = {s: set() for s in bad_networks}
    for subnet, ips in subnets.items():
        if subnet in bad_networks_defs:
            bad_networks_defs[subnet].update(ips)
            # add back unimportant ips in grown subnets
            bad_networks_defs[subnet].update([ip for ip in unimportant if ip in subnet])
        else:
            # search if subnet was clustered into a wider one
            for s in bad_networks_defs:
                if subnet.subnet_of(s):
                    bad_networks_defs[s].update(ips)
                    break

    return bad_networks_defs


class Fail2banClient:
    """
    Simple client for interacting with the Fail2ban client. Based on the
    original source.
    """

    def __init__(self, socket: str) -> None:
        import fail2ban.client.csocket

        self.client = fail2ban.client.csocket.CSocket(socket)

    def _send_command(self, cmd: list[str]) -> list:
        """
        Send a command to the Fail2ban server, and wait for a response.
        """

        ret = self.client.send(cmd)

        if ret[0] != 0:
            return

        return ret[1]

    def close(self):
        self.client.close()

    def get_jail_status(self, jail: str) -> dict:
        """
        Return the status of a specific jail.
        """

        response = self._send_command(["status", jail])

        if not response:
            return []

        # Restructure the response.
        response = {k: v for k, v in response}

        if "Actions" in response:
            response["Actions"] = {k: v for k, v in response["Actions"]}

        if "Filter" in response:
            response["Filter"] = {k: v for k, v in response["Filter"]}

        return response

    def get_status(self) -> list[dict]:
        """
        Return the status information.
        """

        response = self._send_command(["status"])

        if not response:
            return []

        # Restructure the response.
        response = {k: v for k, v in response}

        if "Jail list" in response:
            response["Jail list"] = [
                j.strip() for j in response["Jail list"].split(",")
            ]

        return response

    def get_jails(self) -> list:
        return self.get_status()["Jail list"]

    def set_jail_idle(self, jail: str, idle: bool):
        self._send_command(["set", jail, "idle", idle and "on" or "off"])

    def get_banned(self, jail: str) -> list:
        return self.get_jail_status(jail)["Actions"]["Banned IP list"]

    def _ips_cmd(self, cmd, cmd_log, jail: str, ips):
        if type(ips) is not list:
            logging.debug("jail [%s] %s %s...", jail, cmd_log, ips)
            ips = [ips]
        else:
            logging.debug("jail [%s] %s %d ips/subnets...", jail, cmd_log, len(ips))

        for ip_batch in batched(ips, 10):
            self._send_command(["set", jail, cmd] + ips)

    def ban(self, jail: str, ips: list[str]):
        self._ips_cmd("banip", "Banning", jail, ips)

    def unban(self, jail: str, ips: list[str]):
        self._ips_cmd("unbanip", "Unbanning", jail, ips)


def ban_subnets(args):
    try:
        f2b = Fail2banClient("/var/run/fail2ban/fail2ban.sock")
    except FileNotFoundError:
        logging.error("Could not find fail2ban server socket.")
        sys.exit(1)

    for jail in f2b.get_jails():
        f2b.set_jail_idle(jail, True)

        banned = f2b.get_banned(jail)
        logging.debug("jail [%s] Found %d banned ips", jail, len(banned))

        for badnet, ips in bad_networks(args.count_limit, banned).items():
            if badnet in ips:
                logging.debug(f"jail [{jail}] {badnet} was already banned")
                continue

            no_ips = 0
            no_nets = 0
            for ip in ips:
                if is_network(ip):
                    no_nets = no_nets + 1
                else:
                    no_ips = no_ips + 1
            action_msg = f"jail [{jail}] Identified {badnet} with "
            if no_ips > 0:
                action_msg = action_msg + f"{no_ips} bad ips"
            if no_ips > 0 and no_nets > 0:
                action_msg = action_msg + " and "
            if no_nets > 0:
                action_msg = action_msg + f"{no_nets} bad network(s)"
            logging.info(action_msg)

            if args.dryrun:
                for ip in ips:
                    logging.debug(f"\t{ip}")
            else:
                f2b.unban(jail, list(map(str, ips)))
                f2b.ban(jail, badnet)

        f2b.set_jail_idle(jail, False)

    f2b.close()


def print_subnets(args):
    banned = None
    with open(args.input_file) as f:
        banned = [l.strip() for l in f]

    for badnet, ips in bad_networks(args.count_limit, banned).items():
        logging.debug(f"Network {badnet}:")
        for ip in ips:
            logging.debug(f"\t{ip}")


if __name__ == "__main__":
    count_limit_default = 7

    parser = argparse.ArgumentParser(
        description="Scan fail2ban bans and aggregate single banned IP addresses into banned networks",
        epilog="Defaults: COUNTLIMIT={}".format(str(count_limit_default)),
    )

    parser.add_argument("-v", "--verbose", action="store_true")
    parser.add_argument("-q", "--quiet", action="store_true")
    parser.add_argument("-D", "--dryrun", action="store_true")
    parser.add_argument(
        "-l", "--count-limit", action="store", type=int, default=count_limit_default
    )
    parser.add_argument(
        "-f",
        "--input-file",
        action="store",
        help="Take this plain text file as list of input IPs instead of asking f2b (for testing purposes). Implies --dryrun",
    )

    args = parser.parse_args()

    log = logging.getLogger()

    if os.getenv("INVOCATION_ID"):  # running as systemd unit
        import systemd.journal

        log_handler = systemd.journal.JournalHandler(
            SYSLOG_IDENTIFIER="fail2ban-subnet"
        )
    else:
        log_handler = logging.StreamHandler(sys.stdout)
        log_handler.setFormatter(logging.Formatter("%(levelname)s:%(message)s"))

    if args.verbose:
        log_level = logging.DEBUG
    elif args.quiet:
        log_level = logging.ERROR
    else:
        log_level = logging.INFO

    log.setLevel(log_level)
    log.addHandler(log_handler)

    if args.input_file:
        args.dryrun = True
        print_subnets(args)
    else:
        ban_subnets(args)

    logging.shutdown()
